import { IAssertQueryable } from './IAssertQueryable';
import { IQueryableGroup } from './IQueryableGroup';
import { FreeFunc, Func } from './signtures';
import { InteractiveQuery } from './InteractiveQuery';
import { Predicate, PredeicateIndex, Selector, Rtrn, Sort, Reducer, Action } from './signtures';
declare type JoinBehavior = "left" | "right" | "inner";
export declare type QueryableDefaultReturn<T> = IQueryable<T>;
export interface IQueryableControl<T = any, _TFluent = QueryableDefaultReturn<T>> {
    cast<K>(): IQueryable<K>;
    where(evaluate: Predicate<T>): _TFluent;
    where(evaluate: PredeicateIndex<T>): _TFluent;
    except(evaluate: Predicate<T>): _TFluent;
    except(evaluate: PredeicateIndex<T>): _TFluent;
    notNull(evaluate: FreeFunc<T>): _TFluent;
    isNull(evaluate: FreeFunc<T>): _TFluent;
    toBe<K>(evaluate: Func<T, K>, range: Iterable<K>): _TFluent;
    toBeOut<K>(evaluate: Func<T, K>, range: Iterable<K>): _TFluent;
    between<K = number | Date>(evaluate: Func<T, K>, start: K, end: K): _TFluent;
    exact(element: T): _TFluent;
    match(element: Partial<T>): _TFluent;
    not(element: Partial<T>): _TFluent;
    exlude(element: T): _TFluent;
    distinct(func: FreeFunc<T>): _TFluent;
    whereIf(condition: boolean, evaluate: Predicate<T>): _TFluent;
    whereIf(condition: boolean, evaluate: PredeicateIndex<T>): _TFluent;
    select<K>(map: Selector<T, K>): IQueryable<K>;
    join<TOuter, Result>(query: Iterable<TOuter>, on: (inner: T, outer: TOuter) => boolean, result: (inner: T | null, outer: TOuter | null) => Result, behavior?: JoinBehavior): IQueryable<Result>;
    innerJoin<TOuter, Result>(query: Iterable<TOuter>, on: (inner: T, outer: TOuter) => boolean, result: (inner: T, outer: TOuter) => Result): IQueryable<Result>;
    leftJoin<TOuter, Result>(query: Iterable<TOuter>, on: (inner: T, outer: TOuter) => boolean, result: (inner: T, outer: TOuter | null) => Result | null): IQueryable<Result>;
    rightJoin<TOuter, Result>(query: Iterable<TOuter>, on: (inner: T, outer: TOuter) => boolean, result: (inner: T | null, outer: TOuter) => Result): IQueryable<Result>;
    export(): _TFluent;
    createWith<K>(filter: Predicate<T>, builder: (parent: T, next: (arg: K) => void) => void): IQueryable<K>;
    create<K>(func: (parent: Iterable<T>, next: (arg: K) => void) => void): IQueryable<K>;
    concat(query: Iterable<T>): _TFluent;
    append(query: Iterable<T>): _TFluent;
    orderBy(func: Func<T, any>): _TFluent;
    orderBy(func: Sort<T>): _TFluent;
    orderByDescending(func: Func<T, any>): _TFluent;
    reverse(): _TFluent;
    groupBy<K>(func: Rtrn<K>): IQueryableGroup<K, T>;
    agregate<K>(func: Reducer<T, K>, initial: K | null): K | null;
    assertMode(): IAssertQueryable<T>;
    skip(count: number): _TFluent;
    skipWhile(skip: Predicate<T>): _TFluent;
    take(count: number): _TFluent;
    takeWhile(count: Predicate<T>): _TFluent;
}
export interface IQueryable<T = any, _TFluent = QueryableDefaultReturn<T>> extends IQueryableControl<T, _TFluent>, Iterable<T> {
    any(): boolean;
    all(): boolean;
    contains(element: T): boolean;
    contains(predicate: Predicate<T>): boolean;
    count(): number;
    first(): T;
    single(predicate: Predicate<T>, _def?: T): T | null;
    last(): T;
    random(): T | null;
    toArray(): T[];
    toArrayColumn<K>(columnSelect: Func<T, K>): K[];
    toJson(idented?: boolean): string;
    toSet(): Set<T>;
    toMap(mapper: (arg: T) => [string, T]): Map<string, T>;
    forEach(action: Action<T>): void;
    poll(evaluator: (arg: T) => number, forMax?: boolean): T | null;
    toInteractive(): InteractiveQuery<T>;
}
export {};
