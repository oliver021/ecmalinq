import { IAssertQueryable } from './IAssertQueryable';
import { IQueryable, QueryableDefaultReturn } from './IQueryable';
import { IQueryableGroup } from './IQueryableGroup';
import { Predicate, PredeicateIndex, Selector, Sort, Reducer, Action, FreeFunc, Func } from './signtures';
import { InteractiveQuery } from './InteractiveQuery';
export declare class Queryable<T> implements IQueryable<T> {
    protected source: Iterable<T>;
    private whereClosures;
    private selectClosures;
    private ordersByValue;
    private orderByCoparision;
    private whereConditionClosures;
    private limit;
    private offset;
    private ruleSkip;
    private ruleTake;
    constructor(_source: Iterable<T>);
    create<K>(func: (parent: Iterable<T>, next: (arg: K) => void) => void): IQueryable<K>;
    where(evaluate: Predicate<T>): IQueryable<T>;
    where(evaluate: PredeicateIndex<T>): IQueryable<T>;
    except(evaluate: Predicate<T>): IQueryable<T>;
    except(evaluate: PredeicateIndex<T>): IQueryable<T>;
    notNull(evaluate: FreeFunc<T>): IQueryable<T>;
    isNull(evaluate: FreeFunc<T>): IQueryable<T>;
    toBe<K>(evaluate: Func<T, K>, range: Iterable<K>): IQueryable<T>;
    toBeOut<K>(evaluate: Func<T, K>, range: Iterable<K>): IQueryable<T>;
    between<K = number | Date>(evaluate: Func<T, K>, start: K, end: K, inclusive?: boolean): IQueryable<T>;
    exact(element: T): QueryableDefaultReturn<T>;
    not(element: Partial<T>): QueryableDefaultReturn<T>;
    exlude(element: T): QueryableDefaultReturn<T>;
    match(element: Partial<T>): IQueryable<T>;
    distinct(func: FreeFunc<T>): IQueryable<T>;
    join<TOuter, Result>(query: Iterable<TOuter>, on: (inner: T, outer: TOuter) => boolean, result: (inner: T | null, outer: TOuter | null) => Result, _behavior?: 'left' | 'right' | 'inner'): IQueryable<Result, QueryableDefaultReturn<Result>>;
    innerJoin<TOuter, Result>(query: Iterable<TOuter>, on: (inner: T, outer: TOuter) => boolean, result: (inner: T, outer: TOuter) => Result): IQueryable<Result>;
    leftJoin<TOuter, Result>(query: Iterable<TOuter>, on: (inner: T, outer: TOuter) => boolean, result: (inner: T, outer: TOuter | null) => Result | null): IQueryable<Result>;
    rightJoin<TOuter, Result>(query: Iterable<TOuter>, on: (inner: T, outer: TOuter) => boolean, result: (inner: T | null, outer: TOuter) => Result): IQueryable<Result>;
    export(): IQueryable<T>;
    createWith<K>(filter: Predicate<T>, builder: (element: T, next: (arg: K) => void) => void): IQueryable<K, QueryableDefaultReturn<K>>;
    assertMode(): IAssertQueryable<T>;
    contains(element: T): boolean;
    contains(predicate: Predicate<T>): boolean;
    single(predicate: Predicate<T>, _def?: T): T | null;
    random(): T | null;
    cast<K>(): IQueryable<K>;
    whereIf(condition: boolean, evaluate: Predicate<T>): IQueryable<T>;
    whereIf(condition: boolean, evaluate: PredeicateIndex<T>): IQueryable<T>;
    select<K>(map: Selector<T, K>): IQueryable<K>;
    concat(second: Iterable<T>): IQueryable<T>;
    append(second: Iterable<T>): IQueryable<T>;
    orderBy(func: Func<T, any>): IQueryable<T>;
    orderBy(func: Sort<T>): IQueryable<T>;
    orderByDescending(func: Func<T, any>): IQueryable<T>;
    groupBy<K>(_func: Func<T, any>): IQueryableGroup<K, T>;
    reverse(): IQueryable<T>;
    agregate<K>(func: Reducer<T, K>, initial: K | null): K | null;
    any(): boolean;
    all(): boolean;
    count(): number;
    skip(count: number): IQueryable<T>;
    skipWhile(skip: Predicate<T>): IQueryable<T>;
    take(count: number): IQueryable<T>;
    takeWhile(takeCondition: Predicate<T>): IQueryable<T>;
    first(): T;
    last(): T;
    toArray(): T[];
    toArrayColumn<K>(columnSelect: Func<T, K>): K[];
    toInteractive(): InteractiveQuery<T>;
    toSet(): Set<T>;
    toMap(mapper: (arg: T) => [string, T]): Map<string, T>;
    forEach(action: Action<T>): void;
    poll(evaluator: (arg: T) => number, forMax?: boolean): T | null;
    toJson(_idented?: boolean): string;
    [Symbol.iterator](): Iterator<T, any, undefined>;
    private hasSortsRule;
    private applyFilters;
    private applySorts;
}
